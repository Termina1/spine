// Generated by CoffeeScript 1.3.3
(function() {
  var Cached,
    __slice = [].slice;

  Cached = (function() {

    function Cached(keyStr, data) {
      this.keyStr = keyStr;
      this.data = data;
    }

    Cached.prototype.getData = function() {
      return this.data;
    };

    Cached.prototype.exists = function() {
      return this.data != null;
    };

    return Cached;

  })();

  Spine.AjaxCache = {
    hashf: function(key, seed) {
      var bytes, c1, c2, h1, h1b, i, k1, remainder;
      remainder = key.length & 3;
      bytes = key.length - remainder;
      h1 = seed;
      c1 = 0xcc9e2d51;
      c2 = 0x1b873593;
      i = 0;
      while (i < bytes) {
        k1 = (key.charCodeAt(i) & 0xff) | ((key.charCodeAt(++i) & 0xff) << 8) | ((key.charCodeAt(++i) & 0xff) << 16) | ((key.charCodeAt(++i) & 0xff) << 24);
        ++i;
        k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
        h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
        h1b = (((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16)) & 0xffffffff;
        h1 = ((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16);
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
          break;
        case 2:
          k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
          break;
        case 1:
          k1 ^= key.charCodeAt(i) & 0xff;
          k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
          k1 = (k1 << 15) | (k1 >>> 17);
          k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
          h1 ^= k1;
      }
      h1 ^= key.length;
      h1 ^= h1 >>> 16;
      h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= h1 >>> 13;
      h1 = (((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= h1 >>> 16;
      return h1 >>> 0;
    },
    globalCache: {},
    createKeyString: function(url, params) {
      var el, name, result;
      result = url;
      for (name in params) {
        el = params[name];
        if (!(typeof el === 'function' || typeof el === 'object')) {
          result += "" + name + "=" + el;
        }
      }
      return result;
    },
    hashKey: function(url, params) {
      return this.hashf(this.createKeyString(url, params));
    },
    store: function(url, params, data) {
      var keyStr;
      keyStr = this.hashKey(url, params);
      this.globalCache[keyStr] = new Cached(data);
      return data;
    },
    get: function(url, params) {
      var keyStr;
      keyStr = this.hashKey(url, params);
      return this.globalCache[keyStr] || new Cached;
    }
  };

  Cached.prototype.invalidate = function() {
    return delete AjaxCache.globalCache[this.keyStr];
  };

  Spine.Model.AjaxCache = {
    fetch: function(params, options) {
      var cache, url;
      url = Spine.Ajax.getUrl(this);
      cache = AjaxCache.get(url, params);
      if (cache.exists() && !params.noCache) {
        return this.trigger.apply(this, ['ajaxSuccess'].concat(__slice.call(cache.getData())));
      } else {
        this.one('ajaxSuccess', function(data, status, xhr) {
          return AjaxCache.store(url, params, [data, status, xhr]);
        });
        return fetch.__super__.constructor.call(this, params, options);
      }
    }
  };

}).call(this);
